## 方法一、动态规划
> [AcWing 885. 求组合数 I](https://www.acwing.com/activity/content/problem/content/955/))  
> 适用于 $a,b<10^4$ 大小

### 理论基础

$$
C_a^b = C_{a-1}^b + C_{a-1}^{b-1}  
$$

### 算法思想
通过动态规划的思想构建矩阵，预载入所有组合数的值  

$$
dp[i][j] = 
\begin{cases}
1&j=1\\\\
dp[i-1][j-1]+dp[i-1][j]&j \leq i
\end{cases}
$$

### 算法代码
```
void init(void){
    int n = 2005;
    for(int i=0;i<n;i++){
        for(int j=0;j<=i;j++){
            if(j==0) M[i][j] = 1;
            else M[i][j] = (M[i-1][j]+M[i-1][j-1])%mod;
        }
    }
}
```

## 方法二、预存阶乘
> [AcWing 886. 求组合数 II](https://www.acwing.com/activity/content/problem/content/956/)  
> 适用于 $a,b<10^6$ 大小
### 理论基础

$$
C_b^a = \frac{a!}{b!\*(a-b)!}
$$

### 算法思想
1. 预载入所有阶乘，阶乘逆元（用于分母）
2. 因为模n除法不构成环，所以要用乘法逆元替代除法

$$
fact[i] = fact[i-1]*i\ mod(m)
$$

$$
infact[i] = infact[i-1]*i^{-1}\ mod(m),\ i^{-1}=i^{m-2}\ mod(m)
$$

### 算法代码
```
void init(){
    fact[0] = 1, infact[0] = 1;
    for(int i=1;i<N;i++){
        fact[i] = fact[i-1]*i % mod;
        infact[i] = infact[i-1]*qmi(i,mod-2,mod) % mod;
        //cout<<fact[i]<<" "<<infact[i]<<endl;
    }
    return;
}
```

## 方法三、卢卡斯定理
> [AcWing 887. 求组合数 III](https://www.acwing.com/activity/content/problem/content/957/)
> 适用于 $a,b<10^(18)$ ，结果对某个数取余

### 理论基础
*Lucas定理*

$$
C_b^a\ mod(p)= C_{b\ mod(p)}^{a\ mod(p)} \* C_{b/p}^{a/p}
$$  

### 算法代码
* 朴素求组合数
```
int C(int a,int b,int p){
    int res = 1;
    for(int i=a,j=1;j<=b;j++,i--){
        res = (LL)res * i % p;
        res = (LL)res * qim(j,p) % p;
    }
    return res;
}
```

* *Lucas定理*
```
int lucas(LL a,LL b,LL p){
    if(a<p && b<p) return C(a,b,p);
    return (LL)C(a%p,b%p,p) * lucas(a/p,b/p,p) % p;
}
```

## 方法四、高精度组合数
> [AcWing 888. 求组合数 IV](https://www.acwing.com/activity/content/problem/content/958/)
> 适用于高精度组合数求解

### 算法思想：
* 由 $C_b^a = \frac{a!}{b!\*(a-b)!}$ 可得，通过约分分子分母可以快速计算
* 通过  get_primes_num(n,p) 函数预存n的阶乘中质数p的次方

### 算法代码
```
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int N = 5050;

int primes[N], sum[N], cnt;
bool st[N];

vector<int> mul(vector<int> a, int b){
    int t = 0;
    vector<int> c;

    for(int i=0;i<a.size();i++){
        t += a[i]*b;
        c.push_back(t%10);
        t /= 10;
    }

    while(t){
        c.push_back(t%10);
        t /= 10;
    }

    return c;
}

void get_primes(int n){
    for(int i=2;i<=n;i++){
        if(!st[i]) primes[cnt++] = i;

        for(int j=0;primes[j]<=n/i;j++){
            st[primes[j]*i] = true;
            if(i%primes[j]==0) break;
        }
    }
}

int get_primes_num(int n,int p){ //n 的阶乘中有几个p
    int res = 0;
    while(n){
        res += n/p;
        n /= p;
    }
    return res;
}

int main(void){
    int a, b;
    cin>>a>>b;
    get_primes(a);

    for(int i=0;i<cnt;i++){
        int p = primes[i];
        sum[i] = get_primes_num(a,p) - get_primes_num(b,p) - get_primes_num(a-b,p);
    }

    vector<int> res;
    res.push_back(1); // 不能用res[0]=1

    for(int i=0;i<cnt;i++){
        int p = primes[i];
        int s = sum[i];
        while(s--){
            res = mul(res, p);
        }
    }

    for(int i=res.size()-1;i>=0;i--){
        printf("%d",res[i]);
    }
    puts("");

    return 0;
}

```




















