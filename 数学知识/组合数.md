## 方法一、动态规划
### 理论基础

$$
C_a^b = C_{a-1}^b + C_{a-1}^{b-1}  
$$

### 算法思想
通过动态规划的思想构建矩阵，预载入所有组合数的值  

$$
dp[i][j] = 
\begin{cases}
1&j=1\\\\
dp[i-1][j-1]+dp[i-1][j]&j \leq i
\end{cases}
$$

### 算法代码
```
void init(void){
    int n = 2005;
    for(int i=0;i<n;i++){
        for(int j=0;j<=i;j++){
            if(j==0) M[i][j] = 1;
            else M[i][j] = (M[i-1][j]+M[i-1][j-1])%mod;
        }
    }
}
```

## 方法二、预存阶乘
### 理论基础

$$
C_b^a = \frac{a!}{b!\*(a-b)!}
$$

### 算法思想
1. 预载入所有阶乘，阶乘逆元（用于分母）
2. 因为模n除法不构成环，所以要用乘法逆元替代除法

$$
fact[i] = fact[i-1]*i\ mod(m)
$$

$$
infact[i] = infact[i-1]*i^{-1}\ mod(m),\ i^{-1}=i^{m-2}\ mod(m)
$$

### 算法代码
```
void init(){
    fact[0] = 1, infact[0] = 1;
    for(int i=1;i<N;i++){
        fact[i] = fact[i-1]*i % mod;
        infact[i] = infact[i-1]*qmi(i,mod-2,mod) % mod;
        //cout<<fact[i]<<" "<<infact[i]<<endl;
    }
    return;
}
```






















